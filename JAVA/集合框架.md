数组

#### 数组创建：

```java
dataType[] arrayRefVar = new dataType[arraySize];
```

#### 数组创建并赋值：

```java
dataType[] arrayRefVar = {value0, value1, ..., valuek};
```

实例：

```java
String[] arr = new String[3];  //数据类型是类
//char[] arr = new  char[3];   //数据类型是基本数据类型
arr[0] = "1";
arr[1] = "2";
//[1, 2, null]
System.out.println(Arrays.toString(arr));
```



#### 数组操作方法：

- Array**s**.toString(arr)

  > 打印整个数组内容

- Arrays.sort(arr)

  >升序排序(数组参数必须是整型或浮点型) ，改变原数组

- Arrays.binarySearch(arr,key)

  >查找数组元素(第一个参数是数组字面量，第二个参数是数组索引)

- Arrays.fill(arr,val)

  > 给数组赋值

- Arrays.equals(arr1,arr2)

  > 比较不同数组中元素是否相等，数组的元素类型必须一致

- Objects.equals()

  > 比较元素是否相等

#### 数组的局限：

- 数组初始化后大小不可变；
- 数组只能按索引顺序存取。



### 数组和集合的区别:

1. 长度的区别

- 数组的长度固定

- 集合的长度可变


2. 内容不容

- 数组存储的是同一种类型的元素
- 集合可以存储不同类型的元素(但是一般我们不这样干..)

3. 元素的数据类型

-  数组可以存储基本数据类型,也可以存储引用类型
- 集合只能存储引用类型(你存储的是简单的int，它会自动装箱成Integer)

# 集合框架

### 常见的数据结构

数据结构指的是数据的组存储方式，不同的数据结构有不同的特点。

1. 数组结构（ArrayList底层结构） 　　查询快，增删慢
2. 链表结构（LinkedList底层结构） 　　查询慢，增删快
3. 栈和队列 　　栈：先进后出(子弹夹,杯子) 　　队列：先进先出(排队,管子)

### Collection常见方法：

#### 添加功能： 

-  boolean add(E e)

  > 添加一个元素

- boolean addAll(Collection c)

> 添加一批元素

#### 删除功能：

- boolean remove(Object o) 

  > 删除一个元素

#### 判断功能：

- boolean contains(Object o)

  > 判断集合是否包含指定的元素

- boolean isEmpty()

  > 判断集合是否为空(集合中没有元素)

#### 获取功能

- int size()

  > 获取集合的长度

#### 转换功能

- Object[] toArray()

  > 把集合转换为数组





![集合关系](D:\notes\daily-note\JAVA\img\集合关系.png)

- **接口：**是代表集合的抽象数据类型。定义多个接口，是为了**以不同的方式操作集合对象**

  例如： Collection、List、Set、Map 等

- **实现（类）：**是集合接口的具体实现。从本质上讲，它们是**可重复使用的数据结构**，

  例如：ArrayList、LinkedList、HashSet、HashMap。

- **算法：**是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。

![集合思维导图](D:\notes\daily-note\JAVA\img\集合思维导图.jpg)

### 功能区分：

Collection是一个接口，它是一个高度抽象出来的接口，定义了集合的基本操作： **添加、删除、清空、遍历、是否为空、获取大小**等方法。

Collection 接口有 3 个子接口，List、Set 和 Queue

- List 代表有序、可重复的集合，典型代表就是封装了动态数组的 **ArrayList** 和封装了链表的 LinkedList；

  > LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全
  >
  > **ArrayList** 接口实现类， 数组， 随机访问， 没有同步， 线程不安全
  >
  > Vector 接口实现类 ，数组， 同步， 线程安全（Stack 是Vector类的实现类）

- Set 代表**无序**、**不可重复**的集合，典型代表就是 **HashSet** 和 TreeSet；

  > **HashSet** 使用hash表（数组）存储元素
  >
  > LinkedHashSet 链表维护元素的插入次序
  >
  > TreeSet 底层实现为二叉树，元素排好序

- Queue 代表**队列**，典型代表就是双端队列 ArrayDeque，以及优先级队列 PriorityQue。

- Map，代表**键值对**的集合，典型代表就是 **HashMap**

  > **HashMap**
  >
  > TreeMap （排序）
  >
  > LinkedHashMap （保持插入顺序）

### Set和List的区别

1. Set 接口实例存储的是**无序的，不重复**的数据。List 接口实例存储的是**有序的，可以重复**的元素。

2. Set 检索效率低下，**删除和插入效率高**，插入和删除不会引起元素位置改变 **<实现类有HashSet,TreeSet>**。

3. List 和数组类似，可以动态增长，根据实际存储的数据的长度自动增长 List 的长度。**查找元素效率高**，插入删除效率低，因为会引起其他元素位置改变 **<实现类有ArrayList,LinkedList,Vector>** 。



### 迭代器Iterator

Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代 [ArrayList](https://www.runoob.com/java/java-arraylist.html) 和 [HashSet](https://www.runoob.com/java/java-hashset.html) 等集合。

Java集合使用统一的`Iterator`遍历

1. 创建集合

   ```java
   ArrayList<String> demo = new ArrayList<String>();
   demo.add("hello");
   ```

2. *获取迭代器*

   ```java
   import java.util.Iterator; // 引入 Iterator 类
   
   Iterator<String> it = demo.iterator();
   ```

3. 使用迭代器

   ```java
   //输出集合第一个元素
   it.next();
   //检测集合中是否还有元素
   it.hasNext();
   //将迭代器返回的元素删除。
   it.remove();  
   ```

- `it.next()` 会返回迭代器的下一个元素，并且更新迭代器的状态。

- `it.hasNext()` 用于检测集合中是否还有元素。

- `it.remove()` 将迭代器返回的元素删除（**删除`前方next()`方法输出的值**）。

#### 遍历ArrayList

``` java
import java.util.*;
 
public class Test{
 public static void main(String[] args) {
     List<String> list=new ArrayList<String>();
     list.add("Hello");
     list.add("World");
     list.add("HAHAHAHA");
     //第一种遍历方法使用 For-Each 遍历 List
     for (String str : list) {            //也可以改写 for(int i=0;i<list.size();i++) 这种形式
        System.out.println(str);
     }
 
     //第二种遍历，把链表变为数组相关的内容进行遍历
     String[] strArray=new String[list.size()];
     list.toArray(strArray);
     for(int i=0;i<strArray.length;i++) //这里也可以改写为  for(String str:strArray) 这种形式
     {
        System.out.println(strArray[i]);
     }
     
    //第三种遍历 使用迭代器进行相关遍历
     Iterator<String> ite=list.iterator();
     while(ite.hasNext())//判断下一个元素之后有值
     {
         System.out.println(ite.next());
     }
 }
}
```

####  

### List

![List](D:\notes\daily-note\JAVA\img\List.jpg)

#### List常见方法

- void add(int index, Object ele)

  > 在指定位置添加元素

- boolean addAll(int index, Collection eles)

> 在指定位置添加集合

- Object set(int index, Object ele)

> 修改指定索引位置的值，并返回修改前的值

- int indexOf(Object obj)

  > 返回指定元素在集合中第一次出现的索引位置

- int lastIndexOf(Object obj)

- Object get(int index)

  > 获取指定位置的元素

- List subList(int fromIndex, int toIndex)

  > 截取集合

- Object remove(int index)



### Set

### Map

![Map](D:\notes\daily-note\JAVA\img\Map.jpg)

#### Map常见方法

- `Object put(Object key, Object value)`

  > 添加一个键值对，如果已有一个相同的key，则覆盖

- `void putAll(Map m)`

  > 复制指定Map的键值对到Map中

- `Object get(Object key)`

  > 返回指定key 对应的value，没有返回null

- `Set keySet()`

  >返回Map中所有key组成的set集合（set无序、不重复）

- `Collection values()`

  >返回Map中所有value组成的Collection

- `int size()`

  >返回Map中的键值对个数

- `boolean isEmpty()`

  >查询Map是否为空，返回布尔

- `boolean containsKey(Object key)`

  >查询Map是否包含指定key，返回布尔

- `boolean containsValue(Object value)`

  >查询Map是否包含指定value，返回布尔

- `Object remove(Object key)`

  >删除指定key对应的键值对，并返回删除key对应的value，没有返回null

Entry:

- Set entrySet()

  > 返回Map中键值对组成的Set集合，每个集合都是Map

- Object getKey()

  > 返回Entry里包含的key值

- Object getValue()

  > 返回Entry里包含的value值

- Object setValue(v value)

  >设置Entery里包含的value值，并返回新设置的value值

#### Map遍历

#### 通过键找值的方式

> Set keySet() 返回Map中包含的key的Set集合。 

1. 使用`Set keySet()`方法，获取Map中key值的Set集合
2. 遍历Set集合，用key值通过`Object get(Object key)`获取Map的key值对应的value值

#### 使用Entry 对象遍历

```java
import java.util.*;
 
public class Test{
     public static void main(String[] args) {
      Map<String, String> map = new HashMap<String, String>();
      map.put("1", "value1");
      map.put("2", "value2");
      map.put("3", "value3");
      
      //第一种：普遍使用，二次取值
      System.out.println("通过Map.keySet遍历key和value：");
      for (String key : map.keySet()) {
       System.out.println("key= "+ key + " and value= " + map.get(key));
      }
      
      //第二种
      System.out.println("通过Map.entrySet使用iterator遍历key和value：");
      Iterator<Map.Entry<String, String>> it = map.entrySet().iterator();
      while (it.hasNext()) {
       Map.Entry<String, String> entry = it.next();
       System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());
      }
      
      //第三种：推荐，尤其是容量大时
      System.out.println("通过Map.entrySet遍历key和value");
      for (Map.Entry<String, String> entry : map.entrySet()) {
       System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());
      }
    
      //第四种
      System.out.println("通过Map.values()遍历所有的value，但不能遍历key");
      for (String v : map.values()) {
       System.out.println("value= " + v);
      }
     }
}
```

